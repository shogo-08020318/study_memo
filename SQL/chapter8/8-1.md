# ウィンドウ関数
### ウィンドウ関数とは
ウィンドウ関数は、別名**OLAP関数**とも呼ばれる。
OLAPとは、OnLine Analytical Processingの略で、データベースを使ってリアルタイムにデータ分析を行う処理のこと。
たとえば、以上分析、財務諸表作成、計画作成など。
ウィンドウ関数は、このOLAP用途のために標準SQLに追加された機能である。

### ウィンドウ関数の構文
```sql
<ウィンドウ関数> OVER ([PARTITION BY <列リスト>]
                  ORDER BY <ソート用列リスト>)
```
`[]`は省略可能。
重要なのは、**PARTITION BY**と**ORDER BY**。

**ウィンドウ関数として使える関数**
ウィンドウ関数は、大きく２種類に分かれる。
**①集約関数（SUM、AVG、COUNT、MAX、MIN）をウィンドウ関数として使う**
**②RANK、DENSE_RANK、ROW_NUMBERなどのウィンドウ関数**

②は標準SQLで定義されているOLAP専用の関数なので、関数名を見ればOLAP用途だとすぐにわかる。
①に関しては、上記の構文の`<ウィンドウ関数>`の部分に書くことで、ウィンドウ関数として使用できる。
集約関数は、使用する構文によって集約関数になったりウィンドウ関数になったりする。

### 構文の基本的な使い方---RANK関数の利用
RANKは、名のとおり、レコードのランキング（順位）を算出する関数。
商品テーブルに含まれている8つの商品に対して、商品分類別に、販売単価の安い順に並べたランキング表を作成する。
```sql
SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
       RANK () OVER (PARTITION BY shohin_bunrui
                         ORDER BY hanbai_tanka) AS ranking
  FROM Shohin;
   shohin_mei   | shohin_bunrui | hanbai_tanka | ranking 
----------------+---------------+--------------+---------
 フォーク       | キッチン用品  |          500 |       1
 おろしがね     | キッチン用品  |          880 |       2
 包丁           | キッチン用品  |         3000 |       3
 圧力鍋         | キッチン用品  |         6800 |       4
 ボールペン     | 事務用品      |          100 |       1
 穴あけパンチ   | 事務用品      |          500 |       2
 Tシャツ        | 衣服          |         1000 |       1
 カッターシャツ | 衣服          |         4000 |       2
(8 rows)
```

**PARTITION BY**
順位をつける対象の範囲を指定している。
今回の場合だと、商品分類ごとの順位を抽出しているので、`shohin_bunrui`とした。

**ORDER BY**
どの列を、どんな順序で順位をつけるかを指定している。
販売単価の昇順で順位づけを行うので、`hanbai_tanka`とした。
デフォルトで昇順で、降順にしたければDESCとする。

**PARTITION BY**と**ORDER BY**の作用をわかりやすく言うなら、**PARTITION BY**はテーブルを横方向にカットし、**ORDER BY**が縦方向に順序づけのルールを決める役割を持っている。

ウィンドウ関数は、GROUP BY句のようなカット機能と、ORDER BY句の順序づけの機能の両方を兼ね備えている。
ただし、PARTITION BY句は、GROUP BY句のような集約機能はない。
そのため、RANK関数を使用した結果も、元のテーブルの行数から減ることなく8行出力されている。

また、PARTITION BYによって区切られたレコードの集合を、「ウィンドウ」と呼ぶ。
この場合のウィンドウは「**範囲**」を表す。

### PARTITION BYは指定しなくて良い
ウィンドウ関数を使うときに重要な役割を持つのが、PARTITION BYとORDER BYだが、このうちPARTITION BYは必須ではない。
なら、PARTITION BYを指定しないとどうなるのか。
GROUP BYを使わずに集約関数を使ったときと同じイメージ。
テーブル全体が1つのウィンドウとして扱われる。
```sql
SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
       RANK () OVER (ORDER BY hanbai_tanka) AS ranking
  FROM Shohin;
   shohin_mei   | shohin_bunrui | hanbai_tanka | ranking 
----------------+---------------+--------------+---------
 ボールペン     | 事務用品      |          100 |       1
 フォーク       | キッチン用品  |          500 |       2
 穴あけパンチ   | 事務用品      |          500 |       2
 おろしがね     | キッチン用品  |          880 |       4
 Tシャツ        | 衣服          |         1000 |       5
 包丁           | キッチン用品  |         3000 |       6
 カッターシャツ | 衣服          |         4000 |       7
 圧力鍋         | キッチン用品  |         6800 |       8
(8 rows)
```
今度はテーブル全体でのランキングになった。

### ウィンドウ専用関数の種類
**RANK関数**
ランキングを算出する。
同順位が複数レコード存在した場合、後続の順位が飛ぶ。

**DENSE_RANK関数**
同じくランキングを算出するが、同順位が複数レコード存在しても、後続の順位が飛ばない。

**ROW_NUMBER関数**
一意な連番を付与する。
このこの3つを使ってみる。
```sql
SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
       RANK () OVER (ORDER BY hanbai_tanka) AS ranking,
       DENSE_RANK () OVER (ORDER BY hanbai_tanka) AS dense_ranking,
       ROW_NUMBER () OVER (ORDER BY hanbai_tanka) AS row_num
  FROM Shohin;
   shohin_mei   | shohin_bunrui | hanbai_tanka | ranking | dense_ranking | row_num 
----------------+---------------+--------------+---------+---------------+---------
 ボールペン     | 事務用品      |          100 |       1 |             1 |       1
 フォーク       | キッチン用品  |          500 |       2 |             2 |       2
 穴あけパンチ   | 事務用品      |          500 |       2 |             2 |       3
 おろしがね     | キッチン用品  |          880 |       4 |             3 |       4
 Tシャツ        | 衣服          |         1000 |       5 |             4 |       5
 包丁           | キッチン用品  |         3000 |       6 |             5 |       6
 カッターシャツ | 衣服          |         4000 |       7 |             6 |       7
 圧力鍋         | キッチン用品  |         6800 |       8 |             7 |       8
(8 rows)
```

**RANK**や**ROW_NUMBER**を使うとき、引数を何も書かず、「RANK（）」や「ROW_NUMBER（）」のように、`カッコ（）`の中を空のまま使う。
ウィンドウ関数を使うときは常にそう。
集約関数をウィンドウ関数として使うときとの大きな違い。

### ウィンドウ関数はどこで使うか
ウィンドウ関数は**SELECT**句でしか使うことができない。
SELECT句でしか使えない理由は、ウィンドウ関数がWHERE句やGROUP BY句による処理が終わった「結果」に対して作用するに作られているから。
ランキングを出すにしても、ユーザに結果を返す直前でないと結果が正しくない。

### 集約関数をウィンドウ関数として使う
集約関数をウィンドウ関数として使ってみる。
試しに**SUM**を使ってみる。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka,
       SUM (hanbai_tanka) OVER (ORDER BY shohin_id) AS current_sum
  FROM Shohin;
 shohin_id |   shohin_mei   | hanbai_tanka | current_sum 
-----------+----------------+--------------+-------------
 0001      | Tシャツ        |         1000 |        1000
 0002      | 穴あけパンチ   |          500 |        1500
 0003      | カッターシャツ |         4000 |        5500
 0004      | 包丁           |         3000 |        8500
 0005      | 圧力鍋         |         6800 |       15300
 0006      | フォーク       |          500 |       15800
 0007      | おろしがね     |          880 |       16680
 0008      | ボールペン     |          100 |       16780
(8 rows)
```
**SUM**の場合、**RANK**とは違い引数に集計対象とする列を指定する。
今回の場合、販売単価の合計値を求めている。
また、昇順でレコードを並べて、「自分よりも小さい」商品IDを持つ商品の販売単価を合計している。
ピラミッドを積み上げるように、1つずつ集計の対象が増えていく計算ロジックで、「**累計**」と呼ぶ。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka,
       AVG (hanbai_tanka) OVER (ORDER BY shohin_id) AS current_avg
  FROM Shohin;
 shohin_id |   shohin_mei   | hanbai_tanka |      current_avg      
-----------+----------------+--------------+-----------------------
 0001      | Tシャツ        |         1000 | 1000.0000000000000000
 0002      | 穴あけパンチ   |          500 |  750.0000000000000000
 0003      | カッターシャツ |         4000 | 1833.3333333333333333
 0004      | 包丁           |         3000 | 2125.0000000000000000
 0005      | 圧力鍋         |         6800 | 3060.0000000000000000
 0006      | フォーク       |          500 | 2633.3333333333333333
 0007      | おろしがね     |          880 | 2382.8571428571428571
 0008      | ボールペン     |          100 | 2097.5000000000000000
(8 rows)
```

### 移動平均を算出する
ウィンドウ関数は、テーブルをウィンドウという部分集合にカットして、その中で順序づけを行うようなもの。
ウィンドウの中でさらに集計範囲を細かく指定するオプション機能がある。
そのオプションの集計範囲は「**フレーム**」と呼ぶ。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka,
       AVG (hanbai_tanka) OVER (ORDER BY shohin_id
                                ROWS 2 PRECEDING) AS moving_avg
  FROM Shohin;
 shohin_id |   shohin_mei   | hanbai_tanka |      moving_avg       
-----------+----------------+--------------+-----------------------
 0001      | Tシャツ        |         1000 | 1000.0000000000000000
 0002      | 穴あけパンチ   |          500 |  750.0000000000000000
 0003      | カッターシャツ |         4000 | 1833.3333333333333333
 0004      | 包丁           |         3000 | 2500.0000000000000000
 0005      | 圧力鍋         |         6800 | 4600.0000000000000000
 0006      | フォーク       |          500 | 3433.3333333333333333
 0007      | おろしがね     |          880 | 2726.6666666666666667
 0008      | ボールペン     |          100 |  493.3333333333333333
(8 rows)
```

**フレーム（集計範囲）を指定する**
上記の結果を、先ほどの結果と比較してみると商品ID「0004」の「包丁」以下のレコードで、ウィンドウ関数の計算結果が異なっていることがわかる。
フレームを指定した効果で、集計対象のレコードが「直近の3行」に限定される。
ここでは、**ROWS**（行）と**PRECEDING**（前の）というキーワードを使って、「〜行手前まで」というフレームを指定している。
したがって、「**ROWS 2 PRECEDING**」は「2行前まで」となる。
フレームは、カレントレコードに相対的に決まるため、カレントレコードによって範囲が異なる。

このような集計方法を**移動平均**と呼ぶ。
また、**PRECEDING**の代わりに**FOLLOWING**（後の）を使うことで「〜行後まで」というフレーム指定も可能。

**カレントレコードの前後の行を集計対象煮含める**
カレントレコードの前後の行を対象に含めたいときは、**PRECEDING**と**FOLLOWING**を併用することで実現できる。
**ROWS**の後に**BETWEEN**を使う。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka,
       AVG (hanbai_tanka) OVER (ORDER BY shohin_id
                                 ROWS BETWEEN 1 PRECEDING AND 
                                              1 FOLLOWING) AS moving_avg
  FROM Shohin;
 shohin_id |   shohin_mei   | hanbai_tanka |      moving_avg       
-----------+----------------+--------------+-----------------------
 0001      | Tシャツ        |         1000 |  750.0000000000000000
 0002      | 穴あけパンチ   |          500 | 1833.3333333333333333
 0003      | カッターシャツ |         4000 | 2500.0000000000000000
 0004      | 包丁           |         3000 | 4600.0000000000000000
 0005      | 圧力鍋         |         6800 | 3433.3333333333333333
 0006      | フォーク       |          500 | 2726.6666666666666667
 0007      | おろしがね     |          880 |  493.3333333333333333
 0008      | ボールペン     |          100 |  490.0000000000000000
(8 rows)
```

### 2つのORDER BY
ウィンドウ関数を使ったときの結果の形式に関する注意点。
レコードの並び順について。
ウィンドウ関数を使うときは、必ず**OVER**句の中で**ORDER BY**を使うので、このORDER BYで指定した順序で結果のレコードも並ぶ気がする。
しかし、これはただの錯覚で、**OVER**句ないの**ORDER BY**はあくまでウィンドウ関数がどういう順序で計算するか決めるためだけの役割しか持っていないので、結果の並び順には影響しない。
以下のようにきれいに並ばないことがある。
```sql
SELECT shohin_mei, shohin_bunrui, hanbai_tanka,
       RANK () OVER (ORDER BY hanbai_tanka) AS ranking
  FROM Shohin;
   shohin_mei   | shohin_bunrui | hanbai_tanka | ranking 
----------------+---------------+--------------+---------
 包丁           | キッチン用品  |         3000 |       6
 穴あけパンチ   | 事務用品      |          500 |       2
 カッターシャツ | 衣服          |         4000 |       7
 Tシャツ        | 衣服          |         1000 |       5
 圧力鍋         | キッチン用品  |         6800 |       8
 フォーク       | キッチン用品  |          500 |       2
 おろしがね     | キッチン用品  |          880 |       4
 ボールペン     | 事務用品      |          100 |       1
(8 rows)
```

レコードをきちんとranking列の昇順に並べるにはどうすれば良いか。
**SELECT**文の最後で、**ORDER BY**句による指定をする。
```sql
zSELECT shohin_mei, shohin_bunrui, hanbai_tanka,
       RANK () OVER (ORDER BY hanbai_tanka) AS ranking
  FROM Shohin
 ORDER BY ranking;
   shohin_mei   | shohin_bunrui | hanbai_tanka | ranking 
----------------+---------------+--------------+---------
 ボールペン     | 事務用品      |          100 |       1
 フォーク       | キッチン用品  |          500 |       2
 穴あけパンチ   | 事務用品      |          500 |       2
 おろしがね     | キッチン用品  |          880 |       4
 Tシャツ        | 衣服          |         1000 |       5
 包丁           | キッチン用品  |         3000 |       6
 カッターシャツ | 衣服          |         4000 |       7
 圧力鍋         | キッチン用品  |         6800 |       8
(8 rows)
```
2つの**ORDER BY**は全く違う機能である。
