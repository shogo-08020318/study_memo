# GROUPING演算子
### 合計行も一緒に求めたい
以下のように、「合計」を求めたいときがある。
| 合計 | 16780 |
| ---- | ---- |
| キッチン用品 | 11180 |
| 衣服 | 5000 |
| 事務用品 | 600 |
普通に、GROUP BYを使うと以下のようになる。
```sql
in
 GROUP BY shohin_bunrui;
 shohin_bunrui |  sum  
---------------+-------
 キッチン用品  | 11180
 衣服          |  5000
 事務用品      |   600
(3 rows)
```
GROUP BY句は、集約の軸となるキーを指定する場所なので、ここで指定されたキーによる分割しかできない。
商品分類ごとの合計と、全体の合計を出す方法として、**UNION ALL**を使う方法がある。
```sql
SELECT '合計' AS shohin_bunrui, SUM(hanbai_tanka)
  FROM Shohin
UNION ALL
SELECT shohin_bunrui, SUM(hanbai_tanka)
  FROM Shohin
 GROUP BY shohin_bunrui;
 shohin_bunrui |  sum  
---------------+-------
 合計          | 16780
 キッチン用品  | 11180
 衣服          |  5000
 事務用品      |   600
(4 rows)
```
一応、これでも求める結果は得られるが、ほとんど同じSELECT文を2回実行して、その結果をくっつけるので、見た目も冗長で、DBMS内での処理コストも高くつく。

### ROLLUP---合計と小計を一度の求める
上記のような問題を解消するのが、**GROUPING演算子**である。
これを使うことで、集約谷の違う結果を求めるSQLを簡単に書ける。
演算子の種類には以下のものがある。
- ROLLUP
- CUBE
- GROUPING SETS

**ROLLUPの使い方**
書いてみる。
```sql
SELECT shohin_bunrui, SUM(hanbai_tanka) AS sum_tanka
  FROM Shohin
 GROUP BY ROLLUP(shohin_bunrui);
 shohin_bunrui | sum_tanka 
---------------+-----------
               |     16780
 キッチン用品  |     11180
 衣服          |      5000
 事務用品      |       600
(4 rows)
```
構文としては、**GROUP BY**の集約キーに対して、**ROLLUP（<列１>, <列２>, ...)** のように使う。
この構文の役割は、一言で言うと、「集約キーの組み合わせが異なる結果を一度に計算する」こと。
今回の場合だと、
**①GROUP BY ()**
**②GROUP BY (shohin_bunrui)**
の組み合わせについて計算している。
①は、集約キーなし。つまり、GROUP BYがない場合と同じになり、全体の合計レコードを生む。
これを**超集合行**という。
超集合行の集約キーには、デフォルトで**NULL**が入る。

**集約キーに「登録日」を追加したケース**
集約キーに「登録日」を追加してみる。
ROLLUPなしのほうから。
```sql
SELECT shohin_bunrui, torokubi, SUM(hanbai_tanka) AS sum_tanka
  FROM Shohin
 GROUP BY shohin_bunrui, torokubi;
 shohin_bunrui |  torokubi  | sum_tanka 
---------------+------------+-----------
 キッチン用品  | 2008-04-28 |       880
 キッチン用品  | 2009-09-20 |      3500
 キッチン用品  | 2009-01-15 |      6800
 事務用品      | 2009-09-11 |       500
 事務用品      | 2009-11-11 |       100
 衣服          | 2009-09-20 |      1000
 衣服          |            |      4000
(7 rows)
```
ROLLUPを使ってみる。
```sql
SELECT shohin_bunrui, torokubi, SUM(hanbai_tanka) AS sum_tanka
  FROM Shohin
 GROUP BY ROLLUP(shohin_bunrui, torokubi);
 shohin_bunrui |  torokubi  | sum_tanka 
---------------+------------+-----------
               |            |     16780 ←合計
 キッチン用品  |            |     11180   ←小計（キッチン用品）
 キッチン用品  | 2008-04-28 |       880
 キッチン用品  | 2009-01-15 |      6800
 キッチン用品  | 2009-09-20 |      3500
 事務用品      |            |       600  ←小計（事務用品）
 事務用品      | 2009-09-11 |       500
 事務用品      | 2009-11-11 |       100
 衣服          |            |      5000  ←小計（衣服）
 衣服          | 2009-09-20 |      1000
 衣服          |            |      4000
(11 rows)
```
両者の結果を比較してみると、ROLLUP月の一番上の合計行、および、3つの商品分類についての小計行が追加された。
今回は、次の３パターンをUNIONでつなげた形になっている。
**①GGROUP BY ()**
**②GGROUP BY (shohin_bunrui)**
**③GGROUP BY (shohin_bunrui, torokubi)**

ROLLUPとは「巻き上げる」という意味。
最も粒度の細かい集約レベルから、小計→合計と、集約の単位がどんどん大きくなっていく動作をイメージしたもの。
