# テーブルを集約して検索する
### 集約関数
SQLでデータに対して何らかの操作や計算を行うには、「**関数**」を使う。
例えば、「テーブル全体の行数を合計する」という場合は、**COUNT関数**を使う。
集約する関数は他に以下のようなものがある。
| 関数 | 役割 |
| ---- | ---- |
| COUNT | テーブルのレコード数（行数）を数える |
| SUM | テーブルの数値列のデータを合計する |
| AVG | テーブルの数値列のデータを平均する |
| MAX | テーブルの任意の列のデータの最大値を求める |
| MIN | テーブルの任意の列のデータの最小値を求める |

このような集計用の関数を「**集約関数**」や「**集合関数**」と呼ぶ。

### テーブルの行数を数える
**COUNT**関数を例に考える。
COUNT関数は、**テーブルの列**を入力すると**行数**を出力する。
```sql
SELECT COUNT(*)
  FROM Shohin;
 count 
-------
     8
(1 row)
```
`*`を引数に渡すことで全ての列を意味する。

### NULLを除外して行数を数える
`shohin_tanka`列にあるような**NULL**の行を除外して数えたい場合は、対象とする列を指定して引数に渡す。
```sql
SELECT COUNT(shiire_tanka)
  FROM Shohin;
 count 
-------
     6
(1 row)
```
**NULL**はカウントされないので`6`となる。
**NULL**の行がカウントされないことを確認するために、**NULL**しか含まないテーブルを例に考えてみる。
```sql
SELECT COUNT(*), COUNT(col_1)
  FROM NullTbl;
  count | count
-------+-------
     3       0
(2 row)
```
**COUNT**関数を使ったにもかかわらず、０行となる。**NULL**がカウントされないためである。
この特性は**COUNT**関数だけに当てはまるもので、他の関数だとアスタリスクを引数に渡せないのでエラーになる。

### 合計を求める
例として、**SUM関数**を使って販売単価の合計を求める。
```sql
SELECT SUM(hanbai_tanka)
  FROM Shohin;
  sum  
-------
 16780
(1 row)
```

仕入れ単価も合わせえて求める。
```sql
SELECT SUM(hanbai_tanka), SUM(shiire_tanka)
  FROM Shohin;
  sum  |  sum  
-------+-------
 16780 | 12210
(1 row)
```
ここで、仕入れ単価の計算の内訳を見てみる。
|  | 仕入れ単価 |
| ---- | ---- |
|  | 500 |
|  | 320 |
|  | 2800 |
|  | 2800 |
|  | 5000 |
|  | 790 |
|  | NULL |
| + | NULL |
| 合計 | 12210 |
NULLが含まれる計算は全てNULLになるはず...
すべて集約関数は、列名を引数にとった場合、計算前に**NULL**を除外することになっている。
そのため、**NULL**は含まれないため意図した通りに計算することができる。

### 平均を求める
**AVG関数**を使って複数行の値から平均値を求める。
```sql
SELECT AVG(hanbai_tanka)
  FROM Shohin;
          avg          
-----------------------
 2097.5000000000000000
(1 row)
```

SUM関数と同じように**NULL**を含む場合の計算をしてみる。
```sql
  SELECT AVG(hanbai_tanka), AVG(shiire_tanka)
  FROM Shohin;
          avg          |          avg          
-----------------------+-----------------------
 2097.5000000000000000 | 2035.0000000000000000
(1 row)
```
SUM関数と同様にNULLは除去されて計算される。
NULLのレコードの分だけ分母が減っている。

### 最大値・最小値を求める
**MAX**と**MIN**を使って複数行の中から最大値と最小値を求める。
```sql
SELECT MAX(hanbai_tanka), MIN(shiire_tanka)
  FROM Shohin;
 max  | min 
------+-----
 6800 | 320
(1 row)
```

**MAX MIN**関数は、**SUM AVG**関数と異なる点がある。
**SUM AVG**関数はが数値方の列に対してのみしか用いることができなかったのに対し、**MAX MIN**関数は原則的にどんなデータ型の列に対しても適用可能な点である。
試しに、登録日に対して使ってみる。
```sql
SELECT MAX(torokubi), MIN(torokubi)
  FROM Shohin;
    max     |    min     
------------+------------
 2009-11-11 | 2008-04-28
(1 row)
```
順序がつけられるデータであれば、最大値と最小値も自然と決まるため、適用することができる。

### 重複値を除外して集約関数を使う(DISTINCTキーワード)
`Shohin`テーブルを見ると、`shohin_bunrui`や`hanbai_tanka`で同じ値が複数行に使われている。
｀shohin _bunruiを見ると、テーブルの行数を数えれば８行ですが、種類としては３種類しかない。
「値の種類」の個数を求めるにはどうすればいいか。
重複を除いて数えればいい。
**DISTINCTキーワード**を**COUNT**関数の引数に対して使うことができる。
```sql
SELECT COUNT(DISTINCT shohin_bunrui)
  FROM Shohin;
 count 
-------
     3
(1 row)
```
**DISTINCT**は必ずカッコの中に書かないといけない。
「`shohin_bunri`列を重複行を除外し、その結果の行数を数える」必要があるため。
もし、カッコの外に海底しまうと「最初に`shohin_bunrui`列の行数を数え、それからその結果の重複を除外する」ことになり、結果は`shohin_bunrui`列の全行数（8）となる。
```sql
SELECT DISTINCT COUNT(shohin_bunrui)
  FROM Shohin;
 count 
-------
     8
(1 row)
```

**DISTINCT**は、**COUNT**関数に限らず集約関数ならばどれでも適用できる。
**DISTINCT**を使う場合と使わない場合を**SUM**関数で試す。
```sql
SELECT SUM(hanbai_tanka), SUM(DISTINCT hanbai_tanka)
  FROM Shohin;
  sum  |  sum  
-------+-------
 16780 | 16280
(1 row)
```
**DISTINCT**を使っていない方は、そのまま全ての行を合計値を算出するが、**DISTINCT**を使った方は、`500`円少なくなっている。
これは、販売単価が500円の商品「穴あけパンチ」と「フォーク」が2つテーブルに存在するため、その重複が解消されて１レコードという扱いになっているため。
