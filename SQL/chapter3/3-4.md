# 検索結果を並べ替える
### ORDER BY句
ここでもう一度**SELECT**文を見てみる。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka, shiire_tanka
  FROM Shohin;
 shohin_id |   shohin_mei   | hanbai_tanka | shiire_tanka 
-----------+----------------+--------------+--------------
 0001      | Tシャツ        |         1000 |          500
 0002      | 穴あけパンチ   |          500 |          320
 0003      | カッターシャツ |         4000 |         2800
 0004      | 包丁           |         3000 |         2800
 0005      | 圧力鍋         |         6800 |         5000
 0006      | フォーク       |          500 |             
 0007      | おろしがね     |          880 |          790
 0008      | ボールペン     |          100 |             
(8 rows)
```
今回見たいのは、表示される内容ではなく、表示される行の並び順です。
上記の結果は商品IDの昇順に並んでいるように見えるが、これは偶然である。
選択された結果の並び順は**ランダム**である。
一般的に、テーブルからデータを選択する場合、その順番は、特に指定がない限り、どんな順番で並ぶかは全くわからない。
同じ**SELECT**文ですら、実行するたびに並び順が変わる可能性がある。
しかし、順番がちゃんと並んでいないと、結果を使いづらい場合も多くある。
そういうケースにおいては、**SELECT**文の文末に**ORDER BY**句を付けることで、明示的に行の順序を指定できる。
```sql
SELECT <列名1>, <列名2>, <列名3>, ...
  FROM <テーブル名>
 ORDER BY <並び替えの基準となる列1>, <並び替えの基準となる列2>, ...
 ```
たとえば、販売単価の昇順に並べる場合は、以下のようになる。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka, shiire_tanka
  FROM Shohin
 ORDER BY hanbai_tanka;
 shohin_id |   shohin_mei   | hanbai_tanka | shiire_tanka 
-----------+----------------+--------------+--------------
 0008      | ボールペン     |          100 |             
 0006      | フォーク       |          500 |             
 0002      | 穴あけパンチ   |          500 |          320
 0007      | おろしがね     |          880 |          790
 0001      | Tシャツ        |         1000 |          500
 0004      | 包丁           |         3000 |         2800
 0003      | カッターシャツ |         4000 |         2800
 0005      | 圧力鍋         |         6800 |         5000
(8 rows)
  ↑                                   ↑
商品IDは昇順ではなくなっている          販売単価が昇順になっている
 ```
**ORDER BY**句は必ず、**SELECT**文の最後に書く。
行の並び替え（ソート）は結果を返す直前で行う必要があるからである。
また、**ORDER BYx**句に書く列名を「**ソートキー**」と呼ぶ。
ほかの句と順序関係を表すと以下のようになる。
#### SELECT→FROM→WHERE→GROUP BY→HAVING→ORDER BY

### 昇順と降順の指定
例として、販売単価の高い順、つまり降順に習える場合は、**ORDER BY**の列名の後に、**DESCキーワード**を使う。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka, shiire_tanka
  FROM Shohin
 ORDER BY hanbai_tanka DESC;
 shohin_id |   shohin_mei   | hanbai_tanka | shiire_tanka 
-----------+----------------+--------------+--------------
 0005      | 圧力鍋         |         6800 |         5000
 0003      | カッターシャツ |         4000 |         2800
 0004      | 包丁           |         3000 |         2800
 0001      | Tシャツ        |         1000 |          500
 0007      | おろしがね     |          880 |          790
 0002      | 穴あけパンチ   |          500 |          320
 0006      | フォーク       |          500 |             
 0008      | ボールペン     |          100 |             
(8 rows)
```
今回は、`6800`円の一番高い圧力鍋が最初に来ている。
その後も高い順に並んでいることから、降順になっていることがわかる。

実は、昇順に並べる場合も、正式に**ASC**というキーワードがあるが、省略した場合は暗黙に昇順に並べるようになっている。
これは、実務では昇順に並べる場合が多いための処置であると考えられる。
この**ASC**と**DESC**のキーワードは列単位で指定するものなので、1つの列は昇順を指定し、別の列は降順を指定することも可能。

### 複数のソートキーを指定する
もう一度、販売単価の昇順に並べた**SELECT**文の結果を見てみる。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka, shiire_tanka
  FROM Shohin
 ORDER BY hanbai_tanka;
 shohin_id |   shohin_mei   | hanbai_tanka | shiire_tanka 
-----------+----------------+--------------+--------------
 0008      | ボールペン     |          100 |             
 0006      | フォーク       |          500 |             
 0002      | 穴あけパンチ   |          500 |          320
 0007      | おろしがね     |          880 |          790
 0001      | Tシャツ        |         1000 |          500
 0004      | 包丁           |         3000 |         2800
 0003      | カッターシャツ |         4000 |         2800
 0005      | 圧力鍋         |         6800 |         5000
(8 rows)
```
`500`円の商品が2つあることがわかる。
この同じ値段の商品の順序は、特に指定がない限り、またしても**ランダム**となる。
もし、この「同順位」の商品についても細かく並び順を指定したい場合は、もうひとつソートキーを追加する必要がある。
ここでは、商品IDの昇順とする。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka, shiire_tanka
  FROM Shohin
 ORDER BY hanbai_tanka, shohin_id;
 shohin_id |   shohin_mei   | hanbai_tanka | shiire_tanka 
-----------+----------------+--------------+--------------
 0008      | ボールペン     |          100 |             
 0002      | 穴あけパンチ   |          500 |          320
 0006      | フォーク       |          500 |             
 0007      | おろしがね     |          880 |          790
 0001      | Tシャツ        |         1000 |          500
 0004      | 包丁           |         3000 |         2800
 0003      | カッターシャツ |         4000 |         2800
 0005      | 圧力鍋         |         6800 |         5000
(8 rows)
```
同じ値段の「穴あけパンチ」と「フォーク」のIDがそれぞれ「0002」と「0006」で、今回は昇順のため、「穴あけパンチ」→「フォーク」の順となる。
**ORDER BY**句には、複数のソートキーを使うことができ、左側のキーから優先的に使用され、そのキーで同じ値が存在した場合に、右のキーが参照されるというルール。
3つ以上のソートキーを使用することもできる。

### NULLの順番
次は、`shiire_tanka`列をキーに使ってみる。
このとき問題になるのは、「ボールペン」と「フォーク」の行に含まれている**NULL**である。
**NULL**はどういう順序付けがされるのか。
比較演算子の内容でやった、**NULLに比較演算子は使えない**ことを思い出してみる。
**NULL**と数値の順序付けはできないので、**NULL**を含むソートキーをした場合、**NULL**は先頭または末尾にまとめて表示される。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka, shiire_tanka
  FROM Shohin
 ORDER BY shiire_tanka;
 shohin_id |   shohin_mei   | hanbai_tanka | shiire_tanka 
-----------+----------------+--------------+--------------
 0002      | 穴あけパンチ   |          500 |          320
 0001      | Tシャツ        |         1000 |          500
 0007      | おろしがね     |          880 |          790
 0003      | カッターシャツ |         4000 |         2800
 0004      | 包丁           |         3000 |         2800
 0005      | 圧力鍋         |         6800 |         5000
 0006      | フォーク       |          500 |             
 0008      | ボールペン     |          100 |             
(8 rows)
```
**NULL**の行が先頭に来るか末尾に来るか、特に決まっていない。
中には、先頭か末尾かを指定できるDBMSもある。

### ソートキーに表示用の別名を使う
**GROUP BY**句には、**SELECT**句でつけた列の別名は使うことができなかった。
一方、**ORDER BY**句では別名を使うことができる。
```sql
SELECT shohin_id AS id, shohin_mei, hanbai_tanka AS ht, shiire_tanka
  FROM Shohin
 ORDER BY ht, id;
  id  |   shohin_mei   |  ht  | shiire_tanka 
------+----------------+------+--------------
 0008 | ボールペン     |  100 |             
 0002 | 穴あけパンチ   |  500 |          320
 0006 | フォーク       |  500 |             
 0007 | おろしがね     |  880 |          790
 0001 | Tシャツ        | 1000 |          500
 0004 | 包丁           | 3000 |         2800
 0003 | カッターシャツ | 4000 |         2800
 0005 | 圧力鍋         | 6800 |         5000
(8 rows)
```
これは、「販売単価の昇順」「商品IDの昇順」という、さっきの例と同じ意味である。
なぜ、**GROUP BY**句では使えない別名が**ORDER BY**句では使えるのか。
その理由は、DBMS内部でSQL文が実行される順序にある。
**SELECT**文の実行順序を句単位でみると以下のようになる。
#### FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY
これは大雑把なもので、細かい部分はDBMSによって違う。
ここで重要なのは、**SELECT句の位置がGROUP BYよりも後で、ORDER BYよりも前**にあること。
そのため、**GROUP BY**句が実行される時点では、**SELECT**句でつけることになっている別名を認識できないが、**SELECT**句よりも後ろの**ORDER BY**句ならば、別名を認識できるため使うことができる。

### ORDER BY句に使える列
**ORDER BY**句には、テーブルに存在する列であれば、**SELECT**句に含まれていない列でも指定できる。
```sql
SELECT shohin_mei, hanbai_tanka, shiire_tanka
  FROM Shohin
 ORDER BY shohin_id;
   shohin_mei   | hanbai_tanka | shiire_tanka 
----------------+--------------+--------------
 Tシャツ        |         1000 |          500
 穴あけパンチ   |          500 |          320
 カッターシャツ |         4000 |         2800
 包丁           |         3000 |         2800
 圧力鍋         |         6800 |         5000
 フォーク       |          500 |             
 おろしがね     |          880 |          790
 ボールペン     |          100 |             
(8 rows)
```
また、集約関数も使うことができる。
```sql
SELECT shohin_bunrui, COUNT(*)
  FROM Shohin
 GROUP BY shohin_bunrui
 ORDER BY COUNT(*);
 shohin_bunrui | count 
---------------+-------
 衣服          |     2
 事務用品      |     2
 キッチン用品  |     4
(3 rows)
```
これに**DESC**をつけてみる。
```sql
SELECT shohin_bunrui, COUNT(*)
  FROM Shohin
 GROUP BY shohin_bunrui
 ORDER BY COUNT(*) DESC;
 shohin_bunrui | count 
---------------+-------
 キッチン用品  |     4
 衣服          |     2
 事務用品      |     2
(3 rows)
```
**ORDER BY COUNT(*) DESC**は、**GROUP BY**でグループ化したものをカウントして、それを降順（省略すれば昇順）にするという意味だと認識。

### 列番号は使ってはいけない
**ORDER BY**句では、**SELECT**句に含まれる列を参照する**列番号**を使うことができる。
列番号とは、**SELECT**句で指定した列を左から1、２、３、・・・と、順番を割り振った番号のこと。
従って、以下の2つの**SELECT**文は同じ意味になる。
```sql
SELECT shohin_id, shohin_mei, hanbai_tanka, shiire_tanka
  FROM Shohin
 ORDER BY hanbai_tanka DESC, shohin_id;
 shohin_id |   shohin_mei   | hanbai_tanka | shiire_tanka 
-----------+----------------+--------------+--------------
 0005      | 圧力鍋         |         6800 |         5000
 0003      | カッターシャツ |         4000 |         2800
 0004      | 包丁           |         3000 |         2800
 0001      | Tシャツ        |         1000 |          500
 0007      | おろしがね     |          880 |          790
 0002      | 穴あけパンチ   |          500 |          320
 0006      | フォーク       |          500 |             
 0008      | ボールペン     |          100 |             
(8 rows)
```

```sql
SELECT shohin_id, shohin_mei, hanbai_tanka, shiire_tanka
  FROM Shohin
 ORDER BY 3 DESC, 1;
 shohin_id |   shohin_mei   | hanbai_tanka | shiire_tanka 
-----------+----------------+--------------+--------------
 0005      | 圧力鍋         |         6800 |         5000
 0003      | カッターシャツ |         4000 |         2800
 0004      | 包丁           |         3000 |         2800
 0001      | Tシャツ        |         1000 |          500
 0007      | おろしがね     |          880 |          790
 0002      | 穴あけパンチ   |          500 |          320
 0006      | フォーク       |          500 |             
 0008      | ボールペン     |          100 |             
(8 rows)
```
2つ目の**SELECT**文の**ORDER BY**句は「**SELECT**句の3番目の列で降順ソートし、1番目の列昇順ソートする」という意味になる。
1つ目の**SELECT**文と全く同じ意味になる。
列番号で指定する書き方は、列名を書かなくても良いという手軽さもあって便利だが、次の2つの理由から使うべきではない。
##### 1.コードが読みにくい
列番号を使うと、**ORDER BY**句を見ただけではどんな列をソートキーにしているのかわからず、**SELECT**句のリストを先頭から数えなければいけない。
この例では、列数が少ないので先頭から見てもすぐにわかるが、実務だともっと多いし、**SELECT**句と**ORDER BY**句の間に大きな**WHERE**句や**HAVING**句が挟まって、目で追うことが大変な場合もある。

##### 2.将来削除されるべき機能に挙げられた
今は、問題ないかもしれないが、将来、DBMSのバージョンアップを行った際に、これまで動いていたSQLがエラーになる可能性もある。その場限りの使い捨てのSQLならまだしも、システムに組み込むSQLでこの機能を使うこと避けた方が良い。

### 練習問題
1. **SELECT**文の指摘
- **GOURP BY**で指定しない列を**SELECT**で指定している
- `shohin_mei`は文字列なので、**SUM**関数を使うことができない
- **WHERE**と**GROUP BY**の書き順が逆

2. 販売単価の合計が仕入れ単価の合計の1.5倍より大きい、商品分類を求める
```sql
SELECT shohin_bunrui, SUM(hanbai_tanka), SUM(shiire_tanka)
  FROM Shohin
 GROUP BY shohin_bunrui
HAVING SUM(hanbai_tanka) > SUM(shiire_tanka) * 1.5;
 shohin_bunrui | sum  | sum  
---------------+------+------
 衣服          | 5000 | 3300
 事務用品      |  600 |  320
(2 rows)
```

3. 
```sql
SELECT *
  FROM Shohin
 ORDER BY torokubi DESC, hanbai_tanka;
 shohin_id |   shohin_mei   | shohin_bunrui | hanbai_tanka | shiire_tanka |  torokubi  
-----------+----------------+---------------+--------------+--------------+------------
 0003      | カッターシャツ | 衣服          |         4000 |         2800 | 
 0008      | ボールペン     | 事務用品      |          100 |              | 2009-11-11
 0006      | フォーク       | キッチン用品  |          500 |              | 2009-09-20
 0001      | Tシャツ        | 衣服          |         1000 |          500 | 2009-09-20
 0004      | 包丁           | キッチン用品  |         3000 |         2800 | 2009-09-20
 0002      | 穴あけパンチ   | 事務用品      |          500 |          320 | 2009-09-11
 0005      | 圧力鍋         | キッチン用品  |         6800 |         5000 | 2009-01-15
 0007      | おろしがね     | キッチン用品  |          880 |          790 | 2008-04-28
(8 rows)
```
